git config --global user.email "salvadormuntane@gmail.com" 
git config --global user.name "badorius" 
git version
git init ->crear repo git
git status -> ver que ficheros gestiona git
git add index index.html -> lo pasamos a stageing area, faltara el commit
git status -> para ver index.html en stageing
git commit -m " add index.html" 
#hacemos cambios en el index.html
git status -> veremos que hemos modificado el index.html (tambien lo veremos en el editor)
git add index.html
git commit -m "Aadido el contenido del blog" 
git log -> vemos los dos commits realizados y el que esta activo en el master
git checkout f1daaa3256fff3d246f1a3528ac583309c3fbd33 -> para volver a la version anterior (cogiengo el hash de git log) nos muestra un warging de deatached HEAD
git checkout b69178081f1f594e4603c52b47d31a10ac2d8f4a -> volvemos a la ultima, veremos que el texto en el editor se nos actualiza
git checkout master -> esto nos devuelve al ultimo commit que hemos realizado y dejamos de estar de deatached HEAD. Mas adelante veremos las ramas.

#Como deshacer cambios, no me gusta el ultimo cambio y buscamos una manera mejor de haccerlo
git reset f1daaa -> eliminamos el commit que no queremos, lo revisamos con un git log
git log
git add index.html
git status -> veremos que el index.html ha estado modificado.
git commit -m "Contenido del blog"  -> hacemos el commit con el nuevo cambio 
git log -> lo verificamos
git reset --hard f1daaa -> A diferencia del anterior, este lo elimina de manera definitva todos los cambios del hash en adelante, es cuando lo realizado ya no se quiere.
#recreamos el index.html con el contenido correcto y luego
git add index.html
git commit -m " Contenido del blog" 
git log --oneline -> para que lo muestre en una sola linea


#borramos por error un fichero gestionado con el git (rm index.html) no perdemos nada si no hacemos git reset --hard
git status -> veremos que hemos eliminado el index.html
git restore index.html-> restauramos el fichero index.html
#Todos los archivos y carpetas estan en la carpeta .git

#Aadimos mas ficheros, populamos el fichero style.css y hacemos cambios en el index.html i la img
git add . -> metemos todo el directorio actual en stageing area
git commit -m "Create Navbar"

#Subir contenido en github (se puede subir por ssh o https)
git remote add origin git@github.com:badorius/curso-git.git
git remote -v -> de donde podemos descargar (fetch) o subir (push)
git branch -M main -> cambiar el nombre de la rama, por ahora lo dejaremos como master

#crear claves ssh antes de hacer el push
ssh-keygen -t ed25519 -C "salvadormuntane@gmail.com" (generamos clave publica y privada) en setings de github, subimos la pub
git push -u origin master -> esto solo la primera vez, las siguientes git push 

####como crear ramas, si hay varias personas trabajando en el mismo proyecto, no es buena idea trabajar en la rama principal (master) creamos una bifurcación en la rama principal (master o main) 
####cada uno trabaja en una rama y al final se mezclan las ramas en el master, es mas facil para solucionar conflictos.

git checkout -b feature-posts-styles -> Al igual que antes utilizábamos el checkout para volver a un commit anterior, ahora lo utilizaremos para crear una nueva rama
git branch -> veremos en que rama estamos, en el editor también en la barra inferior.

###Realizamos cambios en el index.html y sytle.css, una vez realizados los cambios, al estar en la rama feature-posts-styles
git status -> revisamos los cambios
git add index.html
git commit -m "Add post html"
git add style.css
git commit -m "Add post style"
#Podriamos añadir los dos ficheros a la vez y realizar un único commit, pero de esta forma lo hacemos más granular.
#aquí hemos finalizado la rama, ahora hay que añadir nuestra rama al master
git log --oneline
#ahora hemos creado una rama en local, pero hay que crearla en github, con esto creamos y subimos la nueva rama
git push -u origin feature-posts-styles
#Tanto en github como en el vscode podremos ver la nueva rama todos los cambios, si cambiamos a la rama master no veremos los cambios de la nueva rama
git checkout master ->cambiamos a master y no vemos los cambios de la rama feautre-posts-estyles
git checkout feature-posts-styles -> cambiamos de nuevo a la rama feature-posts-styles

#En git hub ya nos muestra una alarma de que existe una rama con la opción de compare & pull request.
#Ahora realizaremos otro clone, para simular otra persona trabajando en otra rama. La ruta la copiamos del botón code->ssh de github

git clone git@github.com:badorius/curso-git.git persona-backend

#Volvemos a la rama master y creamos un README.md Antes hacemos los add, commit y push
git add notes.txt 
git status
git commit -m "Add post notes.v3"
git push -u origin feature-posts-styles
git checkout master

#creamos un fichero READM.md y lo populamos, (sintaxis markdown) hacemos add, commit y push, podemos ver el readme en el git. Ahora tenemos modificaciones diferentes en las dos ramas, hasta que no las mezclemos.
#para hacer el merge en github click con compare & pull request le damos un título y creamos el pull request. confirmamos el cambio 

git checkout master
git pull -> hemos descargado los cambios merged en local.

######mezclar rams en local
#Cada vez se nos asigna una tarea, normalmente crearemos una rama nueva y luego haremos el merge.
git checkout -b feature-adds
#modificamos el html
git add .
git commit -m "Add advertisment html"
#Ahora nos damos cuenta que esta nueva rama, será muy complicada y tendremos muchos commits, hacemos una nueva rama dentro de esta ultima


git checkout -b feature-load-adds-from-api
#creamos el index.js y hacemos el commit
git add .
git commit -m "Create load adds function"
#estas ramas solo existen en local, no estan en el gi, a no ser que hagamos un push -u origin $NOMBRE_RAMA
#mezclamos la rama de publicidad y su subrama en local, volvemos a la rama anterior con
git checkout feature-adds
#Una vez en la rama feauture-adds, meclamos la rama en la que estamos con la anterior con feature-load-adds-from-api
git merge feature-load-adds-from-api
#ahora mezclamos todo en github
#Lo podemos subir/crear la rama feature-adds en github y luego hacer el merge en master
git push -u origin feature-adds
#O podriamos pasar en local a master, hacer el merge y luego hacer un push del master
git checkout master
git merge feature-adds

git log --oneline
git log --graph --oneline #vemos los logs de las ramas/tareas

#Un ejemplo, te dan una tarea de backend y  frontend, creas una rama de master de backend y en local creas unasubrama de frontend
#en loccal vas trabajando en una rama, vas cambiando y luego trabajas en otra y cuando las tienes completadas, haces un merge del backend y frontend
#y solo haces un push de una rama para luego hacer un unico merge en el master de tu tarea frontend/backend.


#Como hacer un fork y añadir cambios
#Se puede contribuir a un proyecto open source, descargar un proyecto
#se hace un fork de un repositorio a tu git hub, subir los cambios a tu github y cuando este listo, hacer un merge de tu github a otro repositorio.
#Simularemos un forkk con el mismo git de cursogit
#Vamos a github https://github.com/mastermindac/curso-git, proyecto curso-git y le damos a fork, seleccionamos nuestra cuenta.
#como hacemos cambios en este fork, copiamos el enlace ssh y hacemos un git clone 
#vamos al index.js y ponemos un comentario //video pull request
git clone git@github.com:badorius/curso-git-1.git
#hacemos la modificacion en el index.js y creamos una rama
git checkout -b feature-video-pull-request
git add .
git commit -m "Video pull requesst"
#lo subimos, pero hay que crear la rama en remoto
#si te clonas un repositorio, tiene ya el origin predefinido, lo podemos ver con git remote -v
#como ya tenemos el origin, lo subimos al origin
git push -u origin feature-video-pull-request 
#Ahora en github nos vamos a contribute open pull request, ahí seleccionamos el origen destino, en este caso orgine nuestra rama que haremos merge a la master de mastermindac
#En entornos profesionales, normalmente la rama master es el codigo que hay en producción la que hay en los servidores, luego puede existir, la dev, test, etc.c..

#Como resolver conflictos
#Con un supuesto bug, vamos a issues y creamos un issue Titulo bug... comentarios...
#para resolver el bug, primero siempre un pull para actualizar todos los cambios
git pull
git checkout -b bugfix-2-curso-git -> el numero 2 corresponde al ide de issue en github
#Que pasa si otra persona al mismo tiempo decide arreglar este bug.
git clone git@github.com:badorius/curso-git.git persona2-curso-git
git checkout -b bugfix-2-curso-git-persona2

#Ahora tanto persona 1 como persona 2 suben los cambios
#Persona 1
git add .
git commit -m "Fix #2"
git push -u origin bugfix-2-curso-git

#persona 2
git add .
git commit -m "Fix #2 persona2"
git push -u origin bugfix-2-curso-git-persona2

#ahora vamos github y vemos varias ramas, su historial partio del mismo commit, pero tienen conflictos en los cambios
#mezclaremos la primera rama, seleccionamos la rama,  pull request y merge.
#Hacemos lo mismo con la rama de la persona2 y nos muestra un error de que no se puede hacer merge
#para ver los conflictos, hacemos el  pull request y le damos a resolve conflicts, nos muestra un editor donde nos mostrará el conflicto y podemos rectificar/ver
#Si es algo simple se puede hacer desde github, pero normalmente se puede hacer desde vscode. para hacerlo desde el vscode,
#Nos vamos al git de la persona 1 y hacemos un pull para descargar la ultima version con el bugfix de la persona 1
git pull
#Cambiamos a la rama de la persona dos
git checkout master
git config pull.rebase false 
git pull origin bugfix-2-curso-git-persona2
#en vscode aceptamos o modificamos la version que queremos e incluso podemos añadir algo
git add index.jsgit commit -m "

###Rebase interactivo
git checkout -b feature-affiliate-links -> subiremos esta rama con un único pull request
git branch front -> internamente trabajaremos en dos ramas
git branch back
git checkout back
#editamos indejx.js
git add .
git commit -m "Cambio backend 1"
#editamos index.js cambio 2
--->>
git commit -a -m "Cambio backend 2" --->> con -a hacemos un add y un commit a la vez
--->>
#hacemos lo mismo cambio 3 para tener más comits, editamos el index.js
git commit -a -m "Cambio backend 3" 
#Ahora pasamos al front 
git checkout front
#modificamos el index.html y hacemos -a commit/s
git commit -a -m "Cambio front 1"
#verificamos los cambios
git log -n 3 --oneline
#Tenemos los cambios del back y del front, tenemos que juntarlos y luego hacer un pullrequest
#Solo queremos un commit para cada cosa, back/front
git branch -> Vemos las ramas del repositorio
#Dentro de front mezclamos la rama de back
git merge back
git log -n 7 --oneline
#Ahora limpiaremos los commits antes de hacer el push para limpiar el historial
#dentro de front despues del merge 
git rebase -i feature-affiliate-links -> el rebase nos aplasta la rama hasta la que estemos, al ser interactivo -i nos abre el vim, cambiaremos de pick a squash  para que solo quede un front y un back
#Luego guardamos los squash/pich y nos abre el fichero para modificar los mensajes, borramos los mensajes cambios frontend 1/2/3 a cambios frontend
pick 7c05e02 Cambio frontend1
squash 6afc01c Cambio frontend 2
squash e366146 Cambio notes 2
pick cb4fa06 Cambio backend 1
squash 86310d2 Cambio backend 2
squash b93c8d3 Cambio backend 3
squash 63c2b55 Cambio notes 4

Cambio frontend


#ahora lo revisamos con git log --oneline -n 6
#Ahora lo pasamos a la rama de afiliados

En el minuto 06:34, si hicieramos el rebase estando en feature-affiliate-links y trayendo front, no haría falta hacer el merge del final. Es decir:
git checkout feature-affiliate-links
git rebase -i front
git merge front
git branch -D front back
git push -u origin feature-affiliate-links
#Ahora en github hacemos el pull request, veremos que solo tiene 2 commits
#El rebase solo se recomienda hacer en local, nunca en github ya que generariamos un conflico con el trabajo de otras personas.


###Squase and merge
git checkout master
git pull
git checkout -b feature-videos
#hacemo cambios en index.js
git commit -a -m "Cambios videos 1"
git commit -a -m "Cambios videos 2"
#Ahora nos equivocamos con el titulo del commit y lo queremos modificar
git commit -a -m "Cambios videos 2"
git commit --amend -m "Cambios videos 3" --> Con esto cambiaremos el último titulosiempre que no este subido a github
#ahora subimos a github
git push -u origin feature-videos
#Ahora vamos a guithub para crear el pullrequest, hacemos pullrequest dentro de la rama y después en el botón de merge, desplegamos y teenemos varias opciones
#Rebase que sería la misma que hemos visto en eel capitulo anterior, podemos elegir distintos commits
#Si hacemos un squash, nos los mezclaria todos los commits que tenga esta rama

#Si hacemos cambios en un archivo y luego vemos que los queremos descart, dejar como el original, no hace falta hacer un commit y luego un reset para eliminarlos, podemos hacer un
git restore index.js -> Pone el archivo como estaba en el ultimo commit.

#STASH
git checkout feature-affiliate-links
#hacemos cambios en index.html en algun momento alguien pone un bug issue en afiliados mientras tu estas trabajando. contrl k c (comand comment) <!-- cambio 3 --> 
#Vamos a github i ponemos un issue en afiliates, titulo bug affiliate, en etiquetas podemos poner que es un bug, así saldrá etiquetada como bug, creamosel issue
#una vez abierto el issue, que opciones tenemos:
#podemos aplicar los czmbios que estamos haciendo y hacer un commit en la rama que estamos y abrir una nueva rama para resolver el issue y luego subirlo.
#Otra opción es el stash, más sencillo, deshacemos los cambios realizados, pero no los perdemos, quedan almacenados, no son commits ni stage area,se pueden recuperar en cualquier momento.
#Si hacemos un 
git stash -> desaparecen los cambios del index.html
#Ahora arreglamos el bug, añadiendo una funcion de afiliados en el index.js, hacemos un commit
git add .
git commit -m "Fix affiliate links bug #7"
git push -u origin feature-affiliate-links
#ahora hay que hacer un pullrequest/merge y cerrar el issue
#Ahora para recuperar los cambios en esta misma rama
git stash list (WIP= work in progress, no lo mezcles aún, pero puedes darle un vistazo)
git stash pop -> veremos que recuperamos las entradas que teníamos en el index.html, luego ya podemos hacer un add commit push
git add .
git commit -m "Cambios afiliados"
git push 